using Il2CppModdingCodegen.CppSerialization;
using Il2CppModdingCodegen.Data.DllHandling;
using Il2CppModdingCodegen.Serialization.Interfaces;
using Mono.Cecil;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using static Il2CppModdingCodegen.CppSerialization.CppStreamWriter;

namespace Il2CppModdingCodegen.Serialization
{
    internal class CppTypeSerializer : ISerializer<TypeDefinition, CppStreamWriter>
    {
        private readonly IEnumerable<ISerializer<DllField, CppTypeWriter>> fieldSerializers;
        private readonly IEnumerable<ISerializer<DllMethod, CppTypeWriter>> methodSerializers;
        private readonly IEnumerable<ISerializer<InterfaceImplementation, CppStreamWriter>> earlyInterfaces;
        private readonly IEnumerable<ISerializer<InterfaceImplementation, CppTypeWriter>> lateInterfaces;
        private readonly IEnumerable<ISerializer<TypeDefinition, CppTypeWriter>> nestedSerializers;

        private readonly Dictionary<TypeDefinition, State> typeParentMap = new();

        private readonly struct State
        {
            public readonly List<string> parentNames;
            public readonly string declaring;
            public readonly string type;
            public readonly string il2cppName;

            public State(List<string> p, string d, string t, string i)
            {
                parentNames = p;
                declaring = d;
                type = t;
                il2cppName = i;
            }
        }

        public CppTypeSerializer(IEnumerable<ISerializer<DllField, CppTypeWriter>> fs,
            IEnumerable<ISerializer<DllMethod, CppTypeWriter>> ms,
            IEnumerable<ISerializer<InterfaceImplementation, CppStreamWriter>> @is,
            IEnumerable<ISerializer<InterfaceImplementation, CppTypeWriter>> interfacesLate,
            IEnumerable<ISerializer<TypeDefinition, CppTypeWriter>> ns)
        {
            fieldSerializers = fs;
            methodSerializers = ms;
            earlyInterfaces = @is;
            lateInterfaces = interfacesLate;
            nestedSerializers = ns;
        }

        public void Resolve(CppContext context, TypeDefinition t)
        {
            var parentName = "System::Object";
            if (t.Namespace != "System" || t.Name != "ValueType")
                parentName = context.GetCppName(t.BaseType, true, true, CppContext.NeedAs.Definition, CppContext.ForceAsType.Literal)!;
            List<string> lst;
            string declaring;
            if (t.DeclaringType is not null && t.DeclaringType.HasGenericParameters)
            {
                lst = new List<string>
                {
                    parentName,
                    "::il2cpp_utils::il2cpp_type_check::NestedType"
                };
                context.NeedIl2CppUtils();
                declaring = context.GetCppName(t.DeclaringType, false, true, CppContext.NeedAs.Definition)!;
            }
            else
            {
                lst = new List<string>
                {
                    parentName
                };
                declaring = "";
            }
            State state = new(lst, declaring, context.GetCppName(t, false, false, CppContext.NeedAs.Definition, CppContext.ForceAsType.Literal)!, t.Name);
            typeParentMap.Add(t, state);

            foreach (var i in t.Interfaces)
            {
                foreach (var s in earlyInterfaces)
                {
                    s.Resolve(context, i);
                }
                foreach (var s in lateInterfaces)
                {
                    s.Resolve(context, i);
                }
            }
            foreach (var n in t.NestedTypes)
            {
                foreach (var s in nestedSerializers)
                {
                    s.Resolve(context, n);
                }
            }
            foreach (var f in t.Fields)
            {
                foreach (var s in fieldSerializers)
                {
                    s.Resolve(context, new DllField(f));
                }
            }
            foreach (var m in t.Methods)
            {
                foreach (var s in methodSerializers)
                {
                    s.Resolve(context, new DllMethod(m));
                }
            }
        }

        public void Write(CppStreamWriter writer, TypeDefinition t)
        {
            using var nsw = writer.OpenNamespace(CppContext.CppNamespace(t));
            nsw.WriteComment($"Autogenerated type: {t}");
            int token = -1;
            foreach (var ca in t.CustomAttributes)
            {
                var name = ca.AttributeType.Name;
                if (ca.AttributeType.Name == "TokenAttribute")
                {
                    token = Convert.ToInt32(ca.Fields.First().Argument.Value as string, 16);
                }
                else
                {
                    var loc = new DllCustomAttributeData(ca);
                    nsw.WriteComment($"[{loc.Name}] Offset: {loc.Offset}");
                }
            }
            nsw.WriteComment($"Token: {token}");
            // Get the state
            if (!typeParentMap.TryGetValue(t, out var st))
                throw new InvalidOperationException("Cannot get parent name because it hasn't been resolved!");

            // Write the type definition
            string suffix = "";
            if (t.BaseType is not null)
            {
                suffix = string.Join("public ", st.parentNames.Where(s => !string.IsNullOrEmpty(s)));
            }
            // TODO: Write generic template here, along with correct nested name if UnNested = true, etc, etc.
            using var typeWriter = nsw.OpenType("struct ", st.type, suffix);
            foreach (var i in t.Interfaces)
            {
                foreach (var s in earlyInterfaces)
                {
                    s.Write(writer, i);
                }
            }
            foreach (var n in t.NestedTypes)
            {
                foreach (var s in nestedSerializers)
                {
                    s.Write(typeWriter, n);
                }
            }
            foreach (var f in t.Fields)
            {
                foreach (var s in fieldSerializers)
                {
                    s.Write(typeWriter, new DllField(f));
                }
            }
            foreach (var m in t.Methods)
            {
                foreach (var s in methodSerializers)
                {
                    s.Write(typeWriter, new DllMethod(m));
                }
            }
        }
    }
}